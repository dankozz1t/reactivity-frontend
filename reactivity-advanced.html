<!DOCTYPE html>
<html lang="uk">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Advanced Frontend Reactivity: Deep Dive</title>

    <!-- Prism.js for syntax highlighting -->
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
      rel="stylesheet"
    />
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css"
      rel="stylesheet"
    />

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        overflow: hidden;
      }

      .presentation-container {
        position: relative;
        width: 100vw;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .slide {
        display: none;
        width: 95%;
        max-width: 1400px;
        height: 90%;
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(20px);
        border-radius: 20px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        padding: 30px;
        animation: slideIn 0.5s ease-in-out;
        overflow-y: auto;
      }

      .slide.active {
        display: block;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateX(30px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      h1 {
        font-size: 2.8em;
        margin-bottom: 25px;
        text-align: center;
        background: linear-gradient(45deg, #00f2fe, #4facfe);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      h2 {
        font-size: 2.2em;
        margin-bottom: 20px;
        color: #00f2fe;
        border-bottom: 3px solid #4facfe;
        padding-bottom: 8px;
      }

      h3 {
        font-size: 1.6em;
        margin: 15px 0 10px 0;
        color: #87ceeb;
      }

      h4 {
        font-size: 1.3em;
        margin: 10px 0 8px 0;
        color: #b0e0e6;
      }

      .framework-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 20px;
        margin: 25px 0;
      }

      .framework-card {
        background: rgba(255, 255, 255, 0.15);
        border-radius: 15px;
        padding: 20px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
      }

      .framework-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
      }

      .framework-card::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, #00f2fe, #4facfe);
      }

      .framework-logo {
        font-size: 1.8em;
        margin-bottom: 8px;
        display: block;
      }

      .react {
        color: #61dafb;
      }
      .vue {
        color: #4fc08d;
      }
      .vue2 {
        color: #42b883;
      }
      .vue3 {
        color: #4fc08d;
      }
      .nuxt {
        color: #00dc82;
      }
      .angular {
        color: #dd0031;
      }
      .svelte {
        color: #ff3e00;
      }

      .comparison-table {
        width: 100%;
        border-collapse: collapse;
        margin: 15px 0;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        font-size: 0.9em;
      }

      .comparison-table th,
      .comparison-table td {
        padding: 12px;
        text-align: left;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .comparison-table th {
        background: rgba(255, 255, 255, 0.2);
        font-weight: bold;
        color: #00f2fe;
      }

      .comparison-table tr:hover {
        background: rgba(255, 255, 255, 0.1);
      }

      /* Enhanced code blocks with syntax highlighting */
      .code-container {
        margin: 15px 0;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      }

      .code-header {
        background: rgba(0, 0, 0, 0.6);
        padding: 8px 15px;
        font-size: 0.85em;
        color: #87ceeb;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      pre[class*="language-"] {
        margin: 0 !important;
        background: rgba(0, 0, 0, 0.4) !important;
        border-left: 4px solid #00f2fe;
        font-size: 0.85em !important;
        line-height: 1.4 !important;
      }

      code[class*="language-"] {
        font-family: "Fira Code", "Monaco", "Cascadia Code", "Consolas",
          monospace !important;
      }

      .navigation {
        position: fixed;
        bottom: 25px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 12px;
        z-index: 1000;
      }

      .nav-btn {
        background: rgba(255, 255, 255, 0.2);
        border: none;
        color: white;
        padding: 10px 20px;
        border-radius: 20px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
      }

      .nav-btn:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: scale(1.05);
      }

      .nav-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .slide-counter {
        position: fixed;
        top: 25px;
        right: 25px;
        background: rgba(255, 255, 255, 0.2);
        padding: 8px 16px;
        border-radius: 20px;
        backdrop-filter: blur(10px);
        font-size: 0.9em;
        z-index: 9999;
      }

      .pros-cons {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
        margin: 15px 0;
      }

      .pros,
      .cons {
        background: rgba(255, 255, 255, 0.1);
        padding: 15px;
        border-radius: 10px;
      }

      .pros {
        border-left: 4px solid #4ade80;
      }
      .cons {
        border-left: 4px solid #f87171;
      }

      ul {
        padding-left: 18px;
        margin: 8px 0;
      }

      li {
        margin: 6px 0;
        line-height: 1.5;
      }

      .highlight {
        background: linear-gradient(
          120deg,
          rgba(0, 242, 254, 0.3) 0%,
          rgba(79, 172, 254, 0.3) 100%
        );
        padding: 2px 6px;
        border-radius: 4px;
      }

      .intro-text {
        font-size: 1.2em;
        line-height: 1.7;
        text-align: center;
        margin: 25px 0;
      }

      .concept-box {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        padding: 20px;
        margin: 15px 0;
        border-left: 4px solid #00f2fe;
      }

      .performance-bar {
        height: 18px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 9px;
        overflow: hidden;
        margin: 8px 0;
      }

      .performance-fill {
        height: 100%;
        border-radius: 9px;
        transition: width 2s ease-in-out;
      }

      .react-fill {
        background: linear-gradient(90deg, #61dafb, #21a0c4);
      }
      .vue-fill {
        background: linear-gradient(90deg, #4fc08d, #42a867);
      }
      .vue2-fill {
        background: linear-gradient(90deg, #42b883, #369870);
      }
      .vue3-fill {
        background: linear-gradient(90deg, #4fc08d, #42a867);
      }
      .nuxt-fill {
        background: linear-gradient(90deg, #00dc82, #00b969);
      }
      .angular-fill {
        background: linear-gradient(90deg, #dd0031, #b8002a);
      }
      .svelte-fill {
        background: linear-gradient(90deg, #ff3e00, #cc3200);
      }

      .two-column {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin: 15px 0;
      }

      .deep-dive {
        background: rgba(255, 255, 255, 0.08);
        border-radius: 12px;
        padding: 18px;
        margin: 15px 0;
        border-left: 4px solid #ff6b6b;
      }

      .warning {
        background: rgba(255, 193, 7, 0.2);
        border-left: 4px solid #ffc107;
        padding: 12px;
        border-radius: 8px;
        margin: 10px 0;
      }

      .info {
        background: rgba(23, 162, 184, 0.2);
        border-left: 4px solid #17a2b8;
        padding: 12px;
        border-radius: 8px;
        margin: 10px 0;
      }

      .timeline {
        position: relative;
        padding-left: 30px;
      }

      .timeline::before {
        content: "";
        position: absolute;
        left: 10px;
        top: 0;
        bottom: 0;
        width: 2px;
        background: linear-gradient(180deg, #00f2fe, #4facfe);
      }

      .timeline-item {
        position: relative;
        margin-bottom: 20px;
      }

      .timeline-item::before {
        content: "";
        position: absolute;
        left: -25px;
        top: 5px;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: #00f2fe;
      }

      @media (max-width: 768px) {
        .slide {
          width: 98%;
          padding: 20px;
        }

        h1 {
          font-size: 2.2em;
        }
        h2 {
          font-size: 1.8em;
        }

        .framework-grid {
          grid-template-columns: 1fr;
        }

        .two-column {
          grid-template-columns: 1fr;
        }

        .pros-cons {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="presentation-container">
      <div class="slide-counter">
        <span id="current-slide">1</span> / <span id="total-slides">16</span>
      </div>

      <!-- Slide 1: Title -->
      <div class="slide active">
        <h1>Advanced Frontend Reactivity</h1>
        <div class="intro-text">
          Глибокий аналіз <span class="highlight">реактивності</span><br />
          у сучасних JavaScript фреймворках 2025<br />
          <small style="opacity: 0.8"
            >Vue Vapor Mode, React 19, Angular Signals, Svelte 5 Runes + Edge
            Computing</small
          >
        </div>
        <div class="framework-grid">
          <div class="framework-card">
            <span class="framework-logo react">⚛️</span>
            <h3>React 19+</h3>
            <p>Server Components + React Compiler</p>
          </div>
          <div class="framework-card">
            <span class="framework-logo vue">🖖</span>
            <h3>Vue 3.5 + Vapor Mode</h3>
            <p>Compile-time реактивність без Virtual DOM</p>
          </div>
          <div class="framework-card">
            <span class="framework-logo nuxt">💚</span>
            <h3>Nuxt 2 → Nuxt 3</h3>
            <p>Server-Side Reactivity</p>
          </div>
          <div class="framework-card">
            <span class="framework-logo angular">🅰️</span>
            <h3>Angular 18+</h3>
            <p>Signals Standard + Control Flow</p>
          </div>
          <div class="framework-card">
            <span class="framework-logo svelte">🔥</span>
            <h3>Svelte 5</h3>
            <p>Runes & Fine-grained</p>
          </div>
        </div>
      </div>

      <!-- Slide 2: Reactivity Fundamentals -->
      <div class="slide">
        <h2>Основи Реактивності: Under the Hood</h2>

        <div class="concept-box">
          <h3>Що таке Реактивність насправді?</h3>
          <p>
            <strong>Reactivity</strong> - це здатність системи автоматично
            синхронізувати UI зі станом даних через систему залежностей
            (dependency tracking)
          </p>
        </div>

        <div class="two-column">
          <div>
            <h4>Ключові принципи:</h4>
            <ul>
              <li>
                <strong>Dependency Tracking</strong> - відстеження залежностей
              </li>
              <li><strong>Change Detection</strong> - виявлення змін</li>
              <li><strong>Batched Updates</strong> - групові оновлення</li>
              <li><strong>Schedulers</strong> - планувальники оновлень</li>
              <li><strong>Fine-grained vs Coarse-grained</strong></li>
            </ul>
          </div>
          <div>
            <h4>Типи реактивності:</h4>
            <ul>
              <li><strong>Push-based</strong> (Vue, Angular)</li>
              <li><strong>Pull-based</strong> (React)</li>
              <li><strong>Compile-time</strong> (Svelte)</li>
              <li><strong>Hybrid</strong> (Angular Signals)</li>
            </ul>
          </div>
        </div>

        <div class="code-container">
          <div class="code-header">
            Концептуальний приклад реактивної системи
          </div>
          <pre
            class="line-numbers"
          ><code class="language-javascript">// Концептуальна реактивна система
class ReactiveSystem {
  constructor() {
    this.dependencies = new Map()
    this.subscribers = new Set()
    this.currentEffect = null
  }

  // Відстеження читання (getter trap)
  track(target, key) {
    if (this.currentEffect) {
      this.dependencies.set(key, this.currentEffect)
    }
  }

  // Тригер оновлення (setter trap)
  trigger(target, key) {
    const effect = this.dependencies.get(key)
    if (effect) {
      this.scheduleUpdate(effect)
    }
  }

  // Планувальник оновлень
  scheduleUpdate(effect) {
    queueMicrotask(() => effect())
  }
}</code></pre>
        </div>
      </div>

      <!-- Slide 3: Vue 2 vs Vue 3 Architecture -->
      <div class="slide">
        <h2>Vue Reactivity Evolution: 2 → 3</h2>

        <div class="timeline">
          <div class="timeline-item">
            <h3 class="vue2">Vue 2: Object.defineProperty</h3>
            <p>
              Використання getter/setter для перехоплення доступу до
              властивостей
            </p>
          </div>
          <div class="timeline-item">
            <h3 class="vue3">Vue 3: Proxy API</h3>
            <p>Повне перехоплення операцій з об'єктами на рівні Proxy</p>
          </div>
        </div>

        <div class="two-column">
          <div>
            <h4 class="vue2">Vue 2 Reactivity</h4>
            <div class="code-container">
              <div class="code-header">vue2-reactivity.js</div>
              <pre
                class="line-numbers"
              ><code class="language-javascript">// Vue 2: Object.defineProperty
function defineReactive(obj, key, val) {
  const dep = new Dep()
  
  Object.defineProperty(obj, key, {
    get() {
      // Dependency collection
      if (Dep.target) {
        dep.depend()
      }
      return val
    },
    set(newVal) {
      if (newVal === val) return
      val = newVal
      // Trigger updates
      dep.notify()
    }
  })
}

// Обмеження Vue 2
const data = { count: 0 }
defineReactive(data, 'count', 0)

// ❌ Не реактивно
data.newProp = 'test'
delete data.count

// ✅ Потрібно використовувати
Vue.set(data, 'newProp', 'test')
Vue.delete(data, 'count')</code></pre>
            </div>
          </div>

          <div>
            <h4 class="vue3">Vue 3 Reactivity</h4>
            <div class="code-container">
              <div class="code-header">vue3-reactivity.js</div>
              <pre
                class="line-numbers"
              ><code class="language-javascript">// Vue 3: Proxy API
function reactive(target) {
  return new Proxy(target, {
    get(target, key, receiver) {
      // Track dependency
      track(target, 'get', key)
      return Reflect.get(target, key, receiver)
    },
    
    set(target, key, value, receiver) {
      const oldValue = target[key]
      const result = Reflect.set(target, key, value, receiver)
      
      // Trigger only if value changed
      if (value !== oldValue) {
        trigger(target, 'set', key, value, oldValue)
      }
      return result
    },
    
    has(target, key) {
      track(target, 'has', key)
      return Reflect.has(target, key)
    },
    
    deleteProperty(target, key) {
      const result = Reflect.deleteProperty(target, key)
      trigger(target, 'delete', key)
      return result
    }
  })
}

// ✅ Все реактивно в Vue 3
const state = reactive({ count: 0 })
state.newProp = 'test' // Реактивно!
delete state.count     // Реактивно!</code></pre>
            </div>
          </div>
        </div>
      </div>

      <!-- Slide 4: Vue 3 Deep Dive -->
      <div class="slide">
        <h2 class="vue3">Vue 3 Reactivity Deep Dive</h2>

        <div class="deep-dive">
          <h3>🔍 Як працює реактивність Vue 3 під капотом</h3>
          <p>
            Vue 3 використовує складну систему dependency tracking з effect
            scope та reactive refs
          </p>
        </div>

        <div class="code-container">
          <div class="code-header">@vue/reactivity - Внутрішня реалізація</div>
          <pre
            class="line-numbers"
          ><code class="language-javascript">// Спрощена реалізація Vue 3 reactivity system
let activeEffect = null
const targetMap = new WeakMap()

// Effect (аналог computed/watchEffect)
function effect(fn) {
  const effectFn = () => {
    activeEffect = effectFn
    const result = fn()
    activeEffect = null
    return result
  }
  effectFn()
  return effectFn
}

// Track dependency
function track(target, key) {
  if (!activeEffect) return
  
  let depsMap = targetMap.get(target)
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()))
  }
  
  let dep = depsMap.get(key)
  if (!dep) {
    depsMap.set(key, (dep = new Set()))
  }
  
  dep.add(activeEffect)
}

// Trigger updates
function trigger(target, key) {
  const depsMap = targetMap.get(target)
  if (!depsMap) return
  
  const dep = depsMap.get(key)
  if (dep) {
    dep.forEach(effect => effect())
  }
}</code></pre>
        </div>

        <div class="two-column">
          <div class="info">
            <h4>ref() vs reactive()</h4>
            <div class="code-container">
              <div class="code-header">ref-vs-reactive.js</div>
              <pre
                class="line-numbers"
              ><code class="language-javascript">// ref() - для примітивів
const count = ref(0)
console.log(count.value) // потрібен .value

// reactive() - для об'єктів  
const state = reactive({ count: 0 })
console.log(state.count) // прямий доступ

// Внутрішня різниця:
// ref створює RefImpl з getter/setter
// reactive створює Proxy wrapper</code></pre>
            </div>
          </div>

          <div class="warning">
            <h4>⚠️ Reactive Gotchas</h4>
            <div class="code-container">
              <div class="code-header">common-mistakes.js</div>
              <pre
                class="line-numbers"
              ><code class="language-javascript">// ❌ Втрата реактивності
const state = reactive({ count: 0 })
let { count } = state // Втрачає реактивність!

// ✅ Правильно
const { count } = toRefs(state)

// ❌ Заміна ref
let count = ref(0)
count = ref(1) // Втрачає реактивність!

// ✅ Правильно  
count.value = 1</code></pre>
            </div>
          </div>
        </div>
      </div>

      <!-- Slide 5: Vue Vapor Mode Deep Dive -->
      <div class="slide">
        <h2 class="vue3">Vue Vapor Mode: Compile-Time Reactivity</h2>

        <div class="deep-dive">
          <h3>🚀 Що таке Vapor Mode?</h3>
          <p>
            Vue Vapor Mode - це революційний підхід до компіляції Vue
            компонентів без Virtual DOM, з повною compile-time оптимізацією
            реактивності
          </p>
        </div>

        <div class="two-column">
          <div>
            <h4>Traditional Vue 3 (Runtime)</h4>
            <div class="code-container">
              <div class="code-header">traditional-vue.js</div>
              <pre
                class="line-numbers"
              ><code class="language-javascript">// Traditional Vue 3 - Virtual DOM
function render() {
  return h('div', [
    h('h1', count.value),
    h('button', { 
      onClick: increment 
    }, '+')
  ])
}

// Runtime reactivity
const count = ref(0)
const increment = () => count.value++

// Virtual DOM diffing на runtime
updateComponent()</code></pre>
            </div>
          </div>

          <div>
            <h4>Vue Vapor Mode (Compile-time)</h4>
            <div class="code-container">
              <div class="code-header">vapor-mode.js</div>
              <pre
                class="line-numbers"
              ><code class="language-javascript">// Vapor Mode - Compiled output
function setup() {
  const count = ref(0)
  
  // Direct DOM updates (no Virtual DOM)
  const h1 = document.createElement('h1')
  const button = document.createElement('button')
  
  // Compiled reactive bindings
  effect(() => {
    h1.textContent = count.value
  })
  
  button.onclick = () => count.value++
  
  return [h1, button]
}

// Zero runtime overhead для статичних частин</code></pre>
            </div>
          </div>
        </div>

        <div class="concept-box">
          <h3>Переваги Vapor Mode</h3>
          <ul>
            <li>
              <strong>50%+ менший bundle size</strong> - без Virtual DOM
              overhead
            </li>
            <li><strong>Faster startup</strong> - compile-time оптимізації</li>
            <li><strong>Better performance</strong> - прямі DOM маніпуляції</li>
            <li>
              <strong>Backward compatible</strong> - працює з існуючим кодом
            </li>
            <li><strong>Opt-in</strong> - можна використовувати вибірково</li>
          </ul>
        </div>

        <div class="warning">
          <h4>⚠️ Vapor Mode Status (2025)</h4>
          <p>
            Vapor Mode знаходиться в експериментальній фазі та планується до
            стабільного релізу у Vue 3.6+
          </p>
        </div>
      </div>

      <!-- Slide 6: Composition API vs Options API -->
      <div class="slide">
        <h2>Composition API vs Options API</h2>

        <div class="two-column">
          <div>
            <h3 class="vue2">Options API (Vue 2 style)</h3>
            <div class="code-container">
              <div class="code-header">options-api.vue</div>
              <pre
                class="line-numbers"
              ><code class="language-javascript">// Options API
export default {
  data() {
    return {
      count: 0,
      user: null,
      loading: false
    }
  },
  
  computed: {
    doubleCount() {
      return this.count * 2
    },
    
    isLoggedIn() {
      return !!this.user
    }
  },
  
  watch: {
    count(newVal, oldVal) {
      console.log(`Count: ${oldVal} → ${newVal}`)
    }
  },
  
  async mounted() {
    this.loading = true
    this.user = await fetchUser()
    this.loading = false
  },
  
  methods: {
    increment() {
      this.count++
    }
  }
}</code></pre>
            </div>
          </div>

          <div>
            <h3 class="vue3">Composition API (Vue 3)</h3>
            <div class="code-container">
              <div class="code-header">composition-api.vue</div>
              <pre
                class="line-numbers"
              ><code class="language-javascript">// Composition API
import { ref, computed, watch, onMounted } from 'vue'

export default {
  setup() {
    // Reactive state
    const count = ref(0)
    const user = ref(null)
    const loading = ref(false)
    
    // Computed
    const doubleCount = computed(() => count.value * 2)
    const isLoggedIn = computed(() => !!user.value)
    
    // Watchers
    watch(count, (newVal, oldVal) => {
      console.log(`Count: ${oldVal} → ${newVal}`)
    })
    
    // Lifecycle
    onMounted(async () => {
      loading.value = true
      user.value = await fetchUser()
      loading.value = false
    })
    
    // Methods
    const increment = () => count.value++
    
    return {
      count,
      user,
      loading,
      doubleCount,
      isLoggedIn,
      increment
    }
  }
}</code></pre>
            </div>
          </div>
        </div>

        <div class="concept-box">
          <h3>Переваги Composition API</h3>
          <ul>
            <li>
              <strong>Кращий TypeScript support</strong> - повна типізація
            </li>
            <li>
              <strong>Логічна композиція</strong> - групування пов'язаної логіки
            </li>
            <li>
              <strong>Reusability</strong> - легке переживання через composables
            </li>
            <li><strong>Tree-shaking</strong> - unused код видаляється</li>
          </ul>
        </div>
      </div>

      <!-- Slide 6: Vue Composables -->
      <div class="slide">
        <h2>Vue 3 Composables: Reusable Reactivity</h2>

        <div class="concept-box">
          <h3>Що таке Composables?</h3>
          <p>
            Composables - це функції, які використовують Composition API для
            інкапсуляції та переявлення реактивної логіки
          </p>
        </div>

        <div class="code-container">
          <div class="code-header">useCounter.js - Простий composable</div>
          <pre
            class="line-numbers"
          ><code class="language-javascript">// useCounter.js
import { ref, computed } from 'vue'

export function useCounter(initialValue = 0) {
  const count = ref(initialValue)
  
  const doubleCount = computed(() => count.value * 2)
  const isEven = computed(() => count.value % 2 === 0)
  
  const increment = () => count.value++
  const decrement = () => count.value--
  const reset = () => count.value = initialValue
  
  return {
    // state
    count: readonly(count),
    doubleCount,
    isEven,
    // actions
    increment,
    decrement,
    reset
  }
}</code></pre>
        </div>

        <div class="two-column">
          <div>
            <h4>Використання в компоненті</h4>
            <div class="code-container">
              <div class="code-header">Counter.vue</div>
              <pre
                class="line-numbers"
              ><code class="language-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;h3&gt;Count: {{ count }}&lt;/h3&gt;
    &lt;p&gt;Double: {{ doubleCount }}&lt;/p&gt;
    &lt;p&gt;Is Even: {{ isEven }}&lt;/p&gt;
    
    &lt;button @click="increment"&gt;+&lt;/button&gt;
    &lt;button @click="decrement"&gt;-&lt;/button&gt;
    &lt;button @click="reset"&gt;Reset&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { useCounter } from './useCounter'

const { 
  count, 
  doubleCount, 
  isEven, 
  increment, 
  decrement, 
  reset 
} = useCounter(10)
&lt;/script&gt;</code></pre>
            </div>
          </div>

          <div>
            <h4>Складний composable з API</h4>
            <div class="code-container">
              <div class="code-header">useApi.js</div>
              <pre
                class="line-numbers"
              ><code class="language-javascript">// useApi.js
import { ref, computed } from 'vue'

export function useApi(url) {
  const data = ref(null)
  const error = ref(null)
  const loading = ref(false)
  
  const isLoading = computed(() => loading.value)
  const hasError = computed(() => !!error.value)
  const hasData = computed(() => !!data.value)
  
  const execute = async () => {
    loading.value = true
    error.value = null
    
    try {
      const response = await fetch(url)
      data.value = await response.json()
    } catch (err) {
      error.value = err.message
    } finally {
      loading.value = false
    }
  }
  
  return {
    data: readonly(data),
    error: readonly(error),
    loading: readonly(loading),
    isLoading,
    hasError,
    hasData,
    execute
  }
}</code></pre>
            </div>
          </div>
        </div>
      </div>

      <!-- Slide 7: Nuxt 2 vs Nuxt 3 -->
      <div class="slide">
        <h2>Nuxt Evolution: 2 → 3</h2>

        <div class="timeline">
          <div class="timeline-item">
            <h3 class="vue2">Nuxt 2 (Vue 2 + Options API)</h3>
            <p>Webpack, модульна архітектура, Options API</p>
          </div>
          <div class="timeline-item">
            <h3 class="nuxt">Nuxt 3 (Vue 3 + Composition API)</h3>
            <p>Vite/Webpack, автоімпорти, Composition API, TypeScript</p>
          </div>
        </div>

        <div class="two-column">
          <div>
            <h4>Nuxt 2 Approach</h4>
            <div class="code-container">
              <div class="code-header">pages/index.vue (Nuxt 2)</div>
              <pre
                class="line-numbers"
              ><code class="language-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;{{ title }}&lt;/h1&gt;
    &lt;ul&gt;
      &lt;li v-for="post in posts" :key="post.id"&gt;
        {{ post.title }}
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  // SSR data fetching
  async asyncData({ $axios }) {
    const posts = await $axios.$get('/api/posts')
    return { posts }
  },
  
  data() {
    return {
      title: 'My Blog'
    }
  },
  
  head() {
    return {
      title: this.title,
      meta: [
        { name: 'description', content: 'Blog posts' }
      ]
    }
  }
}
&lt;/script&gt;</code></pre>
            </div>
          </div>

          <div>
            <h4>Nuxt 3 Approach</h4>
            <div class="code-container">
              <div class="code-header">pages/index.vue (Nuxt 3)</div>
              <pre
                class="line-numbers"
              ><code class="language-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;{{ title }}&lt;/h1&gt;
    &lt;ul&gt;
      &lt;li v-for="post in data" :key="post.id"&gt;
        {{ post.title }}
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
// Auto-imported composables
const title = ref('My Blog')

// Server-side data fetching з реактивністю
const { data: posts } = await useFetch('/api/posts')

// SEO та meta tags
useSeoMeta({
  title: title.value,
  description: 'Blog posts'
})

// Head management
useHead({
  title: title.value
})
&lt;/script&gt;</code></pre>
            </div>
          </div>
        </div>

        <div class="concept-box">
          <h3>Ключові відмінності Nuxt 3</h3>
          <ul>
            <li>
              <strong>Auto-imports</strong> - автоматичний імпорт Vue/Nuxt
              composables
            </li>
            <li><strong>Server Engine</strong> - Nitro замість Node.js</li>
            <li>
              <strong>Hybrid Rendering</strong> - ISR, SPA, SSG в одному проекті
            </li>
            <li>
              <strong>TypeScript First</strong> - нативна підтримка без
              налаштувань
            </li>
            <li><strong>Vite by default</strong> - швидша збірка та HMR</li>
          </ul>
        </div>
      </div>

      <!-- Slide 8: Nuxt 3 Advanced Features -->
      <div class="slide">
        <h2 class="nuxt">Nuxt 3: Advanced Reactivity Features</h2>

        <div class="framework-grid">
          <div class="framework-card">
            <h4>Universal Reactivity</h4>
            <div class="code-container">
              <div class="code-header">server-client-reactivity.vue</div>
              <pre
                class="line-numbers"
              ><code class="language-vue">&lt;script setup&gt;
// Працює і на сервері, і на клієнті
const { data: user } = await useFetch('/api/user')

// Реактивне оновлення при зміні роута
const route = useRoute()
watchEffect(() => {
  console.log('Route changed:', route.path)
})

// State що синхронізується між сервером і клієнтом
const sharedState = useState('counter', () => 0)
&lt;/script&gt;</code></pre>
            </div>
          </div>

          <div class="framework-card">
            <h4>Server-Side Composables</h4>
            <div class="code-container">
              <div class="code-header">server-composables.js</div>
              <pre
                class="line-numbers"
              ><code class="language-javascript">// Реактивність на сервері
export default defineEventHandler(async (event) => {
  // Server-only reactive state
  const users = await $fetch('/external-api/users')
  
  // Кешування з реактивністю
  const cachedData = await useStorage('redis').getItem('users')
  
  return {
    users,
    timestamp: new Date(),
    cached: !!cachedData
  }
})</code></pre>
            </div>
          </div>

          <div class="framework-card">
            <h4>Hydration & Islands</h4>
            <div class="code-container">
              <div class="code-header">islands-reactivity.vue</div>
              <pre
                class="line-numbers"
              ><code class="language-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;!-- Static content (SSR) --&gt;
    &lt;h1&gt;{{ title }}&lt;/h1&gt;
    
    &lt;!-- Interactive island --&gt;
    &lt;ClientOnly&gt;
      &lt;InteractiveCounter :initial="count" /&gt;
    &lt;/ClientOnly&gt;
    
    &lt;!-- Lazy hydrated component --&gt;
    &lt;LazyExpensiveChart v-if="showChart" /&gt;
  &lt;/div&gt;
&lt;/template&gt;</code></pre>
            </div>
          </div>
        </div>

        <div class="info">
          <h4>🚀 Nuxt 3 Ecosystem Direction</h4>
          <ul>
            <li>
              <strong>Nuxt Modules</strong> - автоматична інтеграція з
              екосистемою
            </li>
            <li><strong>UnJS</strong> - універсальні JavaScript утиліти</li>
            <li><strong>Nitro</strong> - universal deployment engine</li>
            <li>
              <strong>Nuxt DevTools</strong> - розширені інструменти розробки
            </li>
            <li>
              <strong>Edge-Side Rendering</strong> - виконання на CDN edge
            </li>
          </ul>
        </div>
      </div>

      <!-- Slide 9: React 18+ Advanced Reactivity -->
      <div class="slide">
        <h2 class="react">React 18+: Concurrent Features & New Reactivity</h2>

        <div class="concept-box">
          <h3>React's Reactivity Evolution</h3>
          <p>
            React 18+ додає Concurrent Features, автоматичну батчинг та нові
            хуки для кращої реактивності
          </p>
        </div>

        <div class="two-column">
          <div>
            <h4>Concurrent Features</h4>
            <div class="code-container">
              <div class="code-header">concurrent-react.jsx</div>
              <pre
                class="line-numbers"
              ><code class="language-jsx">// Concurrent rendering
import { Suspense, startTransition, useDeferredValue } from 'react'

function SearchResults({ query }) {
  // Відкладене значення для non-urgent updates
  const deferredQuery = useDeferredValue(query)
  
  return &lt;ExpensiveList query={deferredQuery} /&gt;
}

function App() {
  const [query, setQuery] = useState('')
  
  const handleSearch = (value) => {
    // Urgent update
    setQuery(value)
    
    // Non-urgent update
    startTransition(() => {
      // Expensive operations
      updateSearchResults(value)
    })
  }
  
  return (
    &lt;div&gt;
      &lt;input onChange={(e) => handleSearch(e.target.value)} /&gt;
      
      &lt;Suspense fallback={&lt;Spinner /&gt;}&gt;
        &lt;SearchResults query={query} /&gt;
      &lt;/Suspense&gt;
    &lt;/div&gt;
  )
}</code></pre>
            </div>
          </div>

          <div>
            <h4>Advanced State Management</h4>
            <div class="code-container">
              <div class="code-header">advanced-hooks.jsx</div>
              <pre
                class="line-numbers"
              ><code class="language-jsx">// useReducer для складного стану
const initialState = { count: 0, step: 1 }

function reducer(state, action) {
  switch (action.type) {
    case 'tick':
      return { ...state, count: state.count + state.step }
    case 'step':
      return { ...state, step: action.step }
    default:
      return state
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState)
  const { count, step } = state
  
  // Мемоізація з useMemo
  const expensiveValue = useMemo(() => {
    return calculateExpensiveValue(count)
  }, [count])
  
  // Стабільні функції з useCallback
  const increment = useCallback(() => {
    dispatch({ type: 'tick' })
  }, [])
  
  return (
    &lt;div&gt;
      &lt;h1&gt;{count}&lt;/h1&gt;
      &lt;button onClick={increment}&gt;+{step}&lt;/button&gt;
    &lt;/div&gt;
  )
}</code></pre>
            </div>
          </div>
        </div>

        <div class="warning">
          <h4>⚠️ React Reactivity Gotchas</h4>
          <ul>
            <li>
              <strong>Stale Closures</strong> - застарілі замикання в useEffect
            </li>
            <li><strong>Dependency Arrays</strong> - неправильні залежності</li>
            <li><strong>Unnecessary Re-renders</strong> - зайві рендери</li>
            <li><strong>Object Identity</strong> - перевірка за посиланням</li>
          </ul>
        </div>
      </div>

      <!-- Slide 10: Angular Signals Revolution -->
      <div class="slide">
        <h2 class="angular">Angular 17+: Signals Revolution</h2>

        <div class="concept-box">
          <h3>Від Zone.js до Signals</h3>
          <p>
            Angular вводить Signals як нову основу для реактивності, відходячи
            від Zone.js
          </p>
        </div>

        <div class="two-column">
          <div>
            <h4>Traditional Zone.js Approach</h4>
            <div class="code-container">
              <div class="code-header">zone-js-component.ts</div>
              <pre
                class="line-numbers"
              ><code class="language-typescript">// Zone.js change detection
@Component({
  selector: 'app-counter',
  template: `
    &lt;div&gt;
      &lt;h1&gt;{{ count }}&lt;/h1&gt;
      &lt;button (click)="increment()"&gt;+&lt;/button&gt;
    &lt;/div&gt;
  `,
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class CounterComponent {
  count = 0
  
  increment() {
    this.count++
    // Zone.js автоматично викликає change detection
  }
  
  ngOnInit() {
    // Manually trigger change detection
    setInterval(() => {
      this.count++
      this.cdr.detectChanges()
    }, 1000)
  }
}</code></pre>
            </div>
          </div>

          <div>
            <h4>New Signals Approach</h4>
            <div class="code-container">
              <div class="code-header">signals-component.ts</div>
              <pre
                class="line-numbers"
              ><code class="language-typescript">// Angular Signals
@Component({
  selector: 'app-counter',
  template: `
    &lt;div&gt;
      &lt;h1&gt;{{ count() }}&lt;/h1&gt;
      &lt;h2&gt;Double: {{ doubleCount() }}&lt;/h2&gt;
      &lt;button (click)="increment()"&gt;+&lt;/button&gt;
    &lt;/div&gt;
  `,
  standalone: true
})
export class CounterComponent {
  // Signal state
  count = signal(0)
  
  // Computed signal
  doubleCount = computed(() => this.count() * 2)
  
  // Effect for side effects
  constructor() {
    effect(() => {
      console.log('Count changed:', this.count())
    })
  }
  
  increment() {
    // Update signal
    this.count.update(value => value + 1)
    // або this.count.set(this.count() + 1)
  }
}</code></pre>
            </div>
          </div>
        </div>

        <div class="info">
          <h4>Переваги Angular Signals</h4>
          <ul>
            <li>
              <strong>Fine-grained reactivity</strong> - точкові оновлення
            </li>
            <li><strong>No Zone.js dependency</strong> - кращий performance</li>
            <li><strong>Interoperability</strong> - працює з існуючим кодом</li>
            <li>
              <strong>Better Developer Experience</strong> - менше boilerplate
            </li>
          </ul>
        </div>
      </div>

      <!-- Slide 11: Svelte 5 Runes -->
      <div class="slide">
        <h2 class="svelte">Svelte 5: Runes Revolution</h2>

        <div class="concept-box">
          <h3>Від магічних $: до explicit runes</h3>
          <p>
            Svelte 5 вводить runes - explicit систему реактивності замість
            магічного $: синтаксису
          </p>
        </div>

        <div class="two-column">
          <div>
            <h4>Svelte 4 (магічний синтаксис)</h4>
            <div class="code-container">
              <div class="code-header">svelte4-component.svelte</div>
              <pre
                class="line-numbers"
              ><code class="language-svelte">&lt;script&gt;
  // Reactive variable
  let count = 0
  
  // Reactive statement (магічний $:)
  $: doubleCount = count * 2
  
  // Reactive block
  $: {
    console.log('Count changed:', count)
    if (count > 10) {
      console.log('Count is high!')
    }
  }
  
  // Reactive side effect
  $: updateTitle(count)
  
  function increment() {
    count += 1
  }
  
  function updateTitle(value) {
    document.title = `Count: ${value}`
  }
&lt;/script&gt;

&lt;h1&gt;{count}&lt;/h1&gt;
&lt;p&gt;Double: {doubleCount}&lt;/p&gt;
&lt;button on:click={increment}&gt;+&lt;/button&gt;</code></pre>
            </div>
          </div>

          <div>
            <h4>Svelte 5 (explicit runes)</h4>
            <div class="code-container">
              <div class="code-header">svelte5-component.svelte</div>
              <pre
                class="line-numbers"
              ><code class="language-svelte">&lt;script&gt;
  // State rune
  let count = $state(0)
  
  // Derived rune (замість $:)
  let doubleCount = $derived(count * 2)
  
  // Effect rune (замість $:)
  $effect(() => {
    console.log('Count changed:', count)
    if (count > 10) {
      console.log('Count is high!')
    }
  })
  
  // Effect for side effects
  $effect(() => {
    document.title = `Count: ${count}`
  })
  
  function increment() {
    count += 1
  }
&lt;/script&gt;

&lt;h1&gt;{count}&lt;/h1&gt;
&lt;p&gt;Double: {doubleCount}&lt;/p&gt;
&lt;button onclick={increment}&gt;+&lt;/button&gt;</code></pre>
            </div>
          </div>
        </div>

        <div class="deep-dive">
          <h4>Svelte 5 Runes Explained</h4>
          <ul>
            <li><strong>$state()</strong> - reactive state змінні</li>
            <li><strong>$derived()</strong> - computed values</li>
            <li><strong>$effect()</strong> - side effects</li>
            <li><strong>$props()</strong> - component props</li>
            <li><strong>$bindable()</strong> - two-way binding</li>
          </ul>
        </div>
      </div>

      <!-- Slide 12: Performance Deep Dive -->
      <div class="slide">
        <h2>Performance Deep Dive: Benchmark Analysis</h2>

        <div class="framework-grid">
          <div class="framework-card">
            <h4>Bundle Size Comparison</h4>
            <div>Svelte 5: ~8KB</div>
            <div class="performance-bar">
              <div
                class="performance-fill svelte-fill"
                style="width: 15%"
              ></div>
            </div>
            <div>Vue 3.5: ~36KB</div>
            <div class="performance-bar">
              <div class="performance-fill vue3-fill" style="width: 65%"></div>
            </div>
            <div>Vue Vapor: ~20KB</div>
            <div class="performance-bar">
              <div class="performance-fill vue-fill" style="width: 35%"></div>
            </div>
            <div>React 19: ~45KB</div>
            <div class="performance-bar">
              <div class="performance-fill react-fill" style="width: 80%"></div>
            </div>
            <div>Angular 18: ~130KB</div>
            <div class="performance-bar">
              <div
                class="performance-fill angular-fill"
                style="width: 100%"
              ></div>
            </div>
          </div>

          <div class="framework-card">
            <h4>Reactivity Performance</h4>
            <table class="comparison-table">
              <tr>
                <th>Framework</th>
                <th>Updates/sec</th>
                <th>Memory</th>
                <th>First Paint</th>
              </tr>
              <tr>
                <td class="svelte">Svelte 5</td>
                <td>~120,000</td>
                <td>Lowest</td>
                <td>850ms</td>
              </tr>
              <tr>
                <td class="vue3">Vue 3.5</td>
                <td>~105,000</td>
                <td>Low</td>
                <td>920ms</td>
              </tr>
              <tr>
                <td class="react">React 19</td>
                <td>~85,000</td>
                <td>Medium</td>
                <td>1100ms</td>
              </tr>
              <tr>
                <td class="angular">Angular 18</td>
                <td>~95,000</td>
                <td>Medium</td>
                <td>1200ms</td>
              </tr>
            </table>
          </div>
        </div>

        <div class="two-column">
          <div class="info">
            <h4>🚀 Оптимізації в різних фреймворках</h4>
            <ul>
              <li>
                <strong>Vue 3</strong>: Proxy caching, block tree optimization
              </li>
              <li><strong>React</strong>: Fiber reconciler, time slicing</li>
              <li><strong>Angular</strong>: OnPush strategy, Signals</li>
              <li>
                <strong>Svelte</strong>: Compile-time dead code elimination
              </li>
            </ul>
          </div>

          <div class="warning">
            <h4>⚠️ Performance Anti-patterns</h4>
            <ul>
              <li><strong>Vue</strong>: Reactive arrays з великими datasets</li>
              <li>
                <strong>React</strong>: Inline objects в dependency arrays
              </li>
              <li>
                <strong>Angular</strong>: Zone.js з багатьма event listeners
              </li>
              <li><strong>Svelte</strong>: Складні reactive statements</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- Slide 13: Choosing the Right Framework -->
      <div class="slide">
        <h2>Вибір фреймворку: Decision Matrix</h2>

        <table class="comparison-table">
          <tr>
            <th>Критерій</th>
            <th class="react">React</th>
            <th class="vue">Vue 3</th>
            <th class="angular">Angular</th>
            <th class="svelte">Svelte 5</th>
          </tr>
          <tr>
            <td><strong>Learning Curve</strong></td>
            <td>Середня-Висока</td>
            <td>Легка-Середня</td>
            <td>Висока</td>
            <td>Легка</td>
          </tr>
          <tr>
            <td><strong>Team Size</strong></td>
            <td>Будь-яка</td>
            <td>Мала-Середня</td>
            <td>Велика</td>
            <td>Мала</td>
          </tr>
          <tr>
            <td><strong>Project Scale</strong></td>
            <td>Мала-Величезна</td>
            <td>Мала-Велика</td>
            <td>Велика-Enterprise</td>
            <td>Мала-Середня</td>
          </tr>
          <tr>
            <td><strong>Performance Priority</strong></td>
            <td>Середня</td>
            <td>Висока</td>
            <td>Середня</td>
            <td>Найвища</td>
          </tr>
          <tr>
            <td><strong>Ecosystem</strong></td>
            <td>Найбільша</td>
            <td>Велика</td>
            <td>Велика</td>
            <td>Зростаюча</td>
          </tr>
          <tr>
            <td><strong>TypeScript</strong></td>
            <td>Відмінна</td>
            <td>Відмінна</td>
            <td>Нативна</td>
            <td>Добра</td>
          </tr>
        </table>

        <div class="concept-box">
          <h3>Рекомендації по використанню</h3>
          <div class="framework-grid">
            <div class="framework-card">
              <h4 class="react">Обирайте React, якщо:</h4>
              <ul>
                <li>Потрібна найбільша екосистема</li>
                <li>Команда знає React</li>
                <li>Складний state management</li>
                <li>Mobile (React Native)</li>
              </ul>
            </div>

            <div class="framework-card">
              <h4 class="vue">Обирайте Vue 3, якщо:</h4>
              <ul>
                <li>Швидкий розвиток</li>
                <li>Прогресивне впровадження</li>
                <li>Баланс простоти та потужності</li>
                <li>SSR з Nuxt</li>
              </ul>
            </div>

            <div class="framework-card">
              <h4 class="angular">Обирайте Angular, якщо:</h4>
              <ul>
                <li>Enterprise додатки</li>
                <li>Велика команда</li>
                <li>Строга архітектура</li>
                <li>TypeScript-first</li>
              </ul>
            </div>

            <div class="framework-card">
              <h4 class="svelte">Обирайте Svelte, якщо:</h4>
              <ul>
                <li>Performance критичний</li>
                <li>Мінімальний bundle size</li>
                <li>Прості до середніх проекти</li>
                <li>Швидкий прототипінг</li>
              </ul>
            </div>
          </div>
        </div>
      </div>

      <!-- Slide 14: Future Trends -->
      <div class="slide">
        <h2>Майбутнє Frontend Reactivity</h2>

        <div class="timeline">
          <div class="timeline-item">
            <h3>2024: Signals Everywhere</h3>
            <p>Усі основні фреймворки впроваджують Signals-based reactivity</p>
          </div>
          <div class="timeline-item">
            <h3>2025: Compile-time Optimization</h3>
            <p>Більше оптимізацій на етапі збірки, менше runtime overhead</p>
          </div>
          <div class="timeline-item">
            <h3>2026: Edge Computing</h3>
            <p>Реактивність на CDN edge, розподілений state management</p>
          </div>
        </div>

        <div class="concept-box">
          <h3>🔮 Emerging Trends 2025</h3>
          <ul>
            <li>
              <strong>Edge-First Architecture</strong> - реактивність на CDN
              edge
            </li>
            <li>
              <strong>AI-Powered Optimization</strong> - автоматичні оптимізації
              реактивності
            </li>
            <li>
              <strong>WebAssembly Integration</strong> - WASM-based реактивні
              системи
            </li>
            <li>
              <strong>Streaming Reactivity</strong> - real-time синхронізація
              state
            </li>
            <li>
              <strong>Cross-Platform Reactivity</strong> - универсальні reactive
              системи
            </li>
            <li>
              <strong>Zero-Bundle Reactivity</strong> - повна compile-time
              оптимізація
            </li>
          </ul>
        </div>

        <div class="framework-grid">
          <div class="framework-card">
            <h4 class="react">React 19+ Roadmap</h4>
            <ul>
              <li>
                <strong>React Compiler</strong> - автоматична оптимізація без
                useMemo
              </li>
              <li>
                <strong>Server Components</strong> - стандарт для Next.js та
                інших
              </li>
              <li>
                <strong>Concurrent Features</strong> - покращений Suspense та
                streaming
              </li>
              <li>
                <strong>use() Hook</strong> - нативна підтримка async в
                components
              </li>
              <li>
                <strong>Enhanced DevTools</strong> - React DevTools з AI
                insights
              </li>
            </ul>
          </div>

          <div class="framework-card">
            <h4 class="vue">Vue Ecosystem 2025</h4>
            <ul>
              <li>
                <strong>Vapor Mode</strong> - compile-time реактивність без
                Virtual DOM
              </li>
              <li>
                <strong>Universal Reactivity</strong> - єдина система для
                SSR/CSR/Edge
              </li>
              <li><strong>Nuxt 4</strong> - покращена DX та performance</li>
              <li><strong>Vue DevTools 7</strong> - AI-powered debugging</li>
              <li>
                <strong>Micro-frontend</strong> - нативна підтримка module
                federation
              </li>
            </ul>
          </div>

          <div class="framework-card">
            <h4 class="angular">Angular 18+ Direction</h4>
            <ul>
              <li>
                <strong>Signals Standard</strong> - базова реактивність без
                Zone.js
              </li>
              <li><strong>Material 3 Design</strong> - нова дизайн система</li>
              <li>
                <strong>Control Flow</strong> - @if, @for замість *ngIf, *ngFor
              </li>
              <li>
                <strong>SSR Hydration</strong> - non-destructive hydration
              </li>
              <li>
                <strong>Standalone Everything</strong> - модулі стали
                опціональними
              </li>
            </ul>
          </div>

          <div class="framework-card">
            <h4 class="svelte">Svelte Evolution</h4>
            <ul>
              <li>SvelteKit as standard</li>
              <li>Better tooling ecosystem</li>
              <li>Advanced compilation</li>
              <li>Enterprise adoption</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- Slide 15: Conclusions -->
      <div class="slide">
        <h2>Висновки та Key Takeaways</h2>

        <div class="concept-box">
          <h3>🎯 Головні висновки</h3>
          <ul>
            <li>
              <strong>Реактивність еволюціонує</strong> до fine-grained та
              compile-time оптимізацій
            </li>
            <li>
              <strong>Signals стають стандартом</strong> - всі фреймворки
              рухаються в цьому напрямку
            </li>
            <li>
              <strong>Performance має значення</strong>, але Developer
              Experience теж критичний
            </li>
            <li>
              <strong>Vue екосистема</strong> знаходиться в найкращому стані для
              сучасного розвитку
            </li>
          </ul>
        </div>

        <div class="deep-dive">
          <h3>🚀 Практичні рекомендації</h3>
          <div class="two-column">
            <div>
              <h4>Для нових проектів:</h4>
              <ul>
                <li>
                  Розгляньте <strong>Vue 3 + Nuxt 3</strong> для універсальності
                </li>
                <li>
                  Використовуйте <strong>Svelte 5</strong> для
                  performance-critical додатків
                </li>
                <li>
                  Обирайте <strong>React</strong> для великих команд з досвідом
                </li>
                <li>Angular для enterprise з великою командою</li>
              </ul>
            </div>

            <div>
              <h4>Міграційні стратегії:</h4>
              <ul>
                <li>
                  <strong>Vue 2 → Vue 3</strong>: поступова міграція можлива
                </li>
                <li>
                  <strong>React</strong>: оновлення до React 18+ для Concurrent
                  Features
                </li>
                <li>
                  <strong>Angular</strong>: поступове впровадження Signals
                </li>
                <li>
                  <strong>Svelte 4 → 5</strong>: runes можна вводити поступово
                </li>
              </ul>
            </div>
          </div>
        </div>

        <div style="text-align: center; margin-top: 40px">
          <h2>🎉 Дякую за увагу!</h2>
          <p style="font-size: 1.2em; margin-top: 20px">
            Питання? Обговорення? <br />
            <span class="highlight">Час для Q&A!</span>
          </p>
        </div>
      </div>
    </div>

    <div class="navigation">
      <button class="nav-btn" id="prevBtn" onclick="changeSlide(-1)">
        ← Попередній
      </button>
      <button class="nav-btn" id="nextBtn" onclick="changeSlide(1)">
        Наступний →
      </button>
    </div>

    <!-- Prism.js for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>

    <script>
      let currentSlide = 0;
      const slides = document.querySelectorAll(".slide");
      const totalSlides = slides.length;

      document.getElementById("total-slides").textContent = totalSlides;

      function showSlide(n) {
        slides[currentSlide].classList.remove("active");
        currentSlide = n;

        if (currentSlide >= totalSlides) {
          currentSlide = 0;
        }
        if (currentSlide < 0) {
          currentSlide = totalSlides - 1;
        }

        slides[currentSlide].classList.add("active");
        document.getElementById("current-slide").textContent = currentSlide + 1;

        // Update navigation buttons
        document.getElementById("prevBtn").disabled = currentSlide === 0;
        document.getElementById("nextBtn").disabled =
          currentSlide === totalSlides - 1;
      }

      function changeSlide(direction) {
        showSlide(currentSlide + direction);
      }

      // Keyboard navigation
      document.addEventListener("keydown", function (e) {
        if (e.key === "ArrowLeft") changeSlide(-1);
        else if (e.key === "ArrowRight") changeSlide(1);
        else if (e.key === "Home") showSlide(0);
        else if (e.key === "End") showSlide(totalSlides - 1);
      });

      // Initialize
      showSlide(0);
    </script>
  </body>
</html>
